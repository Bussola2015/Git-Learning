---

#Arquitetura do sistema Git e Github
#workdir -> GitHub-remoto
------------------------- GIT INIT

#somente a primeira vez
git clone https://github.com/Bussola2015/Git-Sketch.git

#posso clonar apenas uma branch
git clone --branch new_feature nome-repositorio
git clone --branch dev https://github.com/Bussola2015/Git-Sketch.git

#inicializa - diz para o Git, quero que esse diretorio seja meu workdir, passe a rastrear tudo aqui (git client)
git init

#inicializa um git serer
git init --bare

OBS: Se você já clonou um repositório com git clone, não precisa usar git init, pois o repositório já está inicializado.git clone https://github.com/sua-conta/seu-fork.gitgit clone https://github.com/sua-conta/seu-fork.gitgit clone https://github.com/sua-conta/seu-fork.git

--------------------------------------- GIT LOG

#history
git log
#history em uma linha cada
git log --oneline
#mais detalhes
git log -p 
#ver apenas determinado autor
git log --author="user_name"
#formatar a visualização
git log --pretty="format:%h %s"

----------------------------------GIT STATUS

#sempre para ver status atual
git status

#diferença de arquivos fore do stage
git diff
#fifere o que está no stage
git diff --staged

git show
---------------------------------- GIT ADD 

#add arquivo area de staging - submetendo (disponivel para commit) | Git passa a monitorar o arquivo/diretorio
git add nome-arquivo1 nome-arquivo2
git add .

#desrastreia o arquivo, ele continua existindo no sistema de arquivo e no diretório de trabalho - não é mais rastreado pelo controle de versão
git rm --cached nome-arquivo   #remove
git commit -m "Remove nome-arquivo do rastreamento"    #para manter controle e legibilidade

OBS: Um arquivo criado no workdir não é automaticamente monitorado pelo Git, precisa explicitamente git add

----------------------------------- GIT COMMIT

#comit individual - maior controle granular
git commit nome-arquivo1 -m "Descrição do commit para o arquivo 1"
git commit nome-arquivo2 -m "Descrição do commit para o arquivo 2"
git commit nome-arquivo3 -m "Descrição do commit para o arquivo 3"
ou 
#tudo de uma vez - vai depender se fazem parte do mesmo contexto de modificação, senão melhor fazer um de cada vez
git commit -m "alterei" 

#fiz comite no local, e quero alterar a mensagem - ele não faz outro comite, apenas altera a mendagem
git commit --amend -m "Trocando a mensagem do último commit"
#modificar um coommit que faltou umarquivo -  lembrando que --amend só funciona para o cmmit do topo (HEAD), se for outro commit é outro processo.
git commit --amend 

#add co-autor no mesmo commit - pessoas que ajudaram no commit - pule duas linhas e escreva como abaixo
git commit -m "Adicionar nova funcionalidade.
>
>
Co-authored-by: NOME <nome@email.com>
Co-authored-by: OUTRO-NOME <outro@email.com>"

------------------------------------- GIT RESTORE|REVERT|RESET

#RESTORE desfaz no escopo de workdir e staging - desfaz arquivos/diretorios não commitados

#me arrependi de monitorar/add quero desfazer submetido - retida do stage (mas continua com modoficações no workdir)
git restore nome-arquivo --staged nome-arquivo

#voltei a rastrear
git add nome-arquivo
#comite para manter o controle
git commit -m "Volta a rastrear nome-arquivo"


#desfaz as alterações no arquivo - undo
git restore nome-arquivo
#Exemplo
git restore Rascunho
git restore index.html

#Traz a versão de um arquivo de um commit antigo para o local atual (sem fazer um commit). Mas é boa prática fazer o commit para manter legibilidade no historico.
git restore --source code-hash nome-arquivo

#volta só um arquivo no tempo
git restore --source 7b6a9ba index.html

#Exemplo
#volta no tempo tudo no workdir - todods os arquivos
git restore --source code-hash .
git restore --source 7b6a9ba .
git push

#REVERT e RESET desfaz commits

#desfazer commits enviados ao repo remoto (push) - volta no tempo - mas nesse comando git revert ID só revertei no local, o push revert no remoto.
git revert c23ae2d
git revert code-hash
#desfaz no repo remoto se foi enviado para o remoto - recomendação sem --force ainda mais se for um repo compartilhado
git push

#git reset ideal para desfazer commits locais

#retira da area de staging
git reset nome-arquivo


#desfaz o último commit mas o(s) arquivo(s) continuam no staging com as modificações
git reset --soft HEAD~1 ou git reset --soft code-hash (ID do commit)
#desfaz 2 commits
git reset --soft HEAD~2
#desfaz 3 commits - e assim por diante
git reset --soft HEAD~3

#desfaz o commit e tira do stage - precisa add novamente - no workdir o arquivo ainda está modificado
git reset --mixed HEAD~1

#desfaz o commit e destarta as modificações dos arquivos (apaga e sobrescreve os arquivos)
git reset --hard HEAD~1

OBS: para remover um commit, precisamos selecionar um commit anterior ao que queremos remover, isso vale apenas se estivermos utilizando ID de commit.

--------------------------------------- GIT CONFIG

#config com repo github modo global - identificar quem é o autor dos commits
git config --global user.email "you@example.com"
git config --global user.name "Your Name"

#config com repo github modo local - identificar quem é o autor dos commits
git config user.email "you@example.com"
git config user.name "Your Name"

--------------------------------------- GIT PUSH|PULL|REMOTE

#enviar para o Github
git push origin main
git push repositorio nova-branch  #git push origin dev

#se eu tiver certeza do que estou fazendo, pode forçar a escrita no remoto
git push origin main --force

#vincula a branch local com a branch remota. Depois desse comando você não precisa espeficcar qual o repo e a branch, ex: git push ou git pull
git push -u origin main

#depois do clone, preciso sincronizar com origin (GitHub), utilizo pull
git pull https://github.com/Bussola2015/Git-Sketch.git
#se já tem vinculo não precisa colocar URL
git pull

#sem merge
git pull --rebase

OBS: git pull=git fetch+(git merge ou git rebase)

#se eu tiver em outra brach
git pull repositorio branch
git pull origin dev

#add outro repo ao workdir - posso ter quantos quiser e não somente o origin inicial
git remote add origin https://github.com/usuario/repo.git
#lista meus repo remoto vinculados
git remote -v  

#remover repo remoto
git remote remove origin

#alterar o nome padrão origin
git remote rename origin novo-origin

#check se tem identificador definido
git config --list

git config user.name
git config user.email
------------------------------------ .GITIGNORE

.gitignore #pode ser encontrado no workdir, Github remoto e em subdiretórios


------------------------------------ BRANCH
#criar branch e entra nela
git checkout -b nova-branch   
ou 
git switch -c nome-da-branch

#criar branch
git branch nome-nova-branch

#alterar de branch
git checkout nome-nova-branch
ou 
git switch nome-branch

#Listar branches existentes:
git branch

#lista as branch com mais detalhes
git branch -v
git branch -vv

#Branches remotas
#Listar branches remotas:
git branch -r

#Listar todas as branches (locais e remotas)
git branch -a

#Criar uma branch local a partir de uma branch remota:
git checkout -b nome-da-branch origin/nome-da-branch

#Excluir uma branch:
git branch -d nome-da-branch

#Forçar exclusão da branch
git branch -D nome-da-branch

#Renomear uma branch
git branch -m novo-nome

#força o renomeio 
git branch -M novo nome

#Para renomear uma branch específica:
git branch -m nome-antigo novo-nome

---------------------------------------------------- FORK

# Como funciona o fluxo:
# Você faz o fork:
# O repositório original é copiado para a sua conta no GitHub (fork).
# Agora você tem controle total sobre o fork.
# Clona o fork para o seu workdir:
# Você clona o repositório forkado para o seu computador:
git clone https://github.com/sua-conta/seu-fork.git

# Adiciona o repositório original como remoto adicional (upstream):
# Para acompanhar as alterações do repositório original, adicione-o como um remoto chamado upstream:
git remote add upstream https://github.com/usuario-original/repo-original.git


# Verifica as alterações no repositório original:
# Use o comando git fetch upstream para buscar as alterações do repositório original (upstream):
git fetch upstream

# Isso não altera sua branch local. Ele apenas atualiza as referências locais para as branches do repositório original.
# Verifica as alterações sem aplicá-las:
# Você pode ver os commits ou alterações disponíveis no repositório original:
git log upstream/main

# O que acontece no seu workdir?
# O comando git fetch upstream não altera sua branch local ou seu repositório remoto (fork no GitHub).
# Ele apenas atualiza as referências locais para as branches do repositório original (upstream), permitindo que você veja as alterações disponíveis.
# Se quiser aplicar as alterações do repositório original ao seu fork:
# Mescle as alterações do repositório original com sua branch local:
git merge upstream/main

# Envie as alterações para o seu fork no GitHub:
git push origin main

#Resumo:
# Use git fetch upstream para buscar as alterações do repositório original sem alterar nada no seu repositório local ou remoto.
# Isso acontece no workdir, após você ter clonado o fork e configurado o repositório original como upstream.


------------------------------------------------ GIT MERGE
#merge - fundir/unir uma branch na outra branch
#precisa estar no branch que será o DESTINO das mudanças - estou na dev quero merge com a main -> git switch main -> git merge dev (o inverso para main quero merge com a dev)

git merge nome-branch

