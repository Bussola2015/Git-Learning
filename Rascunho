---

#Arquitetura do sistema Git e Github
#workdir tree -> GitHub-remoto
------------------------- GIT INIT

#somente a primeira vez
git clone https://github.com/Bussola2015/Git-Sketch.git

#posso clonar apenas uma branch
git clone --branch new_feature nome-repositorio
git clone --branch dev https://github.com/Bussola2015/Git-Sketch.git

#inicializa - diz para o Git, quero que esse diretorio seja meu workdir, passe a rastrear tudo aqui (git client)
git init

#inicializa um git server em um diretório - repositório bare (sem workdir)
git init --bare

OBS: Se você já clonou um repositório com git clone, não precisa usar git init, pois o repositório já está inicializado.git clone https://github.com/sua-conta/seu-fork.gitgit clone https://github.com/sua-conta/seu-fork.gitgit clone https://github.com/sua-conta/seu-fork.git

--------------------------------------- GIT LOG

#history
git log
#history em uma linha cada
git log --oneline
#mais detalhes
git log -p 
#ver apenas determinado autor
git log --author="user_name"
#formatar a visualização
git log --pretty="format:%h %s"

git log --graph

git log --format="%h - %an, %ar : %s"

#mostra somente os últimos 2 commits
git log -n 2

#log de branch especifica
git log nome-branch

----------------------------------GIT STATUS

#sempre para ver status atual
git status

----------------------------------- GIT DIFF | SHOW 

#arquivos modificados, não commitados no workdir com o último commit no repo local - compara estados entre arquivos no workdir não commitados e o último commit
git diff
#difere o que está no stage
git diff --staged
#mostra a diferença em um intervalo de mudanças entre commits 
git diff ID-commit..ID-commit

#mostra as mudanças em determinado commit
git show ID-commit

#mostra as mudanças do último commit (HEAD é o ponteiro para o último commit)
git show 

#git diff mostra a diferença entre commits
#git show mostra as mudanças realizados por determinado commit

---------------------------------- GIT ADD 

#add arquivo area de staging - submetendo (disponivel para commit) | Git passa a monitorar o arquivo/diretorio
git add nome-arquivo1 nome-arquivo2
git add .

#desrastreia o arquivo, ele continua existindo no sistema de arquivo e no diretório de trabalho - não é mais rastreado pelo controle de versão
git rm --cached nome-arquivo   #remove
git commit -m "Remove nome-arquivo do rastreamento"    #para manter controle e legibilidade

OBS: Um arquivo criado no workdir não é automaticamente monitorado pelo Git, precisa explicitamente git add

----------------------------------- GIT COMMIT

#comit individual - maior controle granular
git commit nome-arquivo1 -m "Descrição do commit para o arquivo 1"
git commit nome-arquivo2 -m "Descrição do commit para o arquivo 2"
git commit nome-arquivo3 -m "Descrição do commit para o arquivo 3"
ou 
#tudo de uma vez - vai depender se fazem parte do mesmo contexto de modificação, senão melhor fazer um de cada vez
git commit -m "alterei" 

#fiz comite no local, e quero alterar a mensagem - ele não faz outro comite, apenas altera a mendagem
git commit --amend -m "Trocando a mensagem do último commit"
#modificar um commit que faltou um arquivo - lembrando que --amend só funciona para o commit do topo (HEAD), se for outro commit é outro processo.
git add arquivo
git commit --amend 

#add co-autor no mesmo commit - pessoas que ajudaram no commit - pule duas linhas e escreva como abaixo
git commit -m "Adicionar nova funcionalidade.
>
>
Co-authored-by: NOME <nome@email.com>
Co-authored-by: OUTRO-NOME <outro@email.com>"

------------------------------------- GIT RESTORE|REVERT|RESET

#RESTORE desfaz no escopo de workdir e staging - desfaz arquivos/diretorios não commitados

#retida do stage (mas continua com modificações no workdir)
git restore nome-arquivo --staged nome-arquivo

#voltei a rastrear
git add nome-arquivo
#comite para manter o controle
git commit -m "Volta a rastrear nome-arquivo"


#desfaz as alterações no arquivo - undo ou CTRL+Z - Para o estado do último commit (HEAD)
git restore nome-arquivo ou git restore --source HEAD nome-arquivo
#Exemplo
git restore Rascunho
git restore index.html

#desfaz todas as alterações dos arquivos no workdir - Para o estado do último commit (HEAD)
git restore .
git checkout -- . #equivale ao comando acima

#Traz a versão de um arquivo de um commit antigo para o local atual (sem fazer um commit e não altera histórico). Mas é boa prática fazer o commit para manter legibilidade no historico.
git restore --source code-hash nome-arquivo

#volta só um arquivo no tempo
git restore --source 7b6a9ba index.html

#Exemplo
#volta no tempo tudo no workdir - todos os arquivos
git restore --source code-hash .
git restore --source 7b6a9ba .
git push

#REVERT e RESET desfaz commits - mas faz commit para registrar a reversão

#desfazer commits enviados ao repo remoto (push) - volta no tempo desfazendo commits - cria um novo commit que desfaz as alterações do commit selecionado
git revert c23ae2d
git revert code-hash
#desfaz no repo remoto se foi enviado para o remoto - recomendação sem --force ainda mais se for um repo compartilhado
git push

#git reset ideal para desfazer commits locais (repo local)

#retira da area de staging
git reset nome-arquivo 
git restore nome-arquivo --staged nome-arquivo


#desfaz o último commit mas o(s) arquivo(s) continuam no staging com as modificações
git reset --soft HEAD~1 ou git reset --soft code-hash (ID do commit)
#desfaz 2 commits
git reset --soft HEAD~2
#desfaz 3 commits - e assim por diante
git reset --soft HEAD~3

#desfaz o commit e tira do stage - precisa add novamente - no workdir o arquivo ainda está modificado
git reset --mixed HEAD~1

#desfaz o commit e destarta as modificações dos arquivos (apaga e sobrescreve os arquivos)
git reset --hard HEAD~1

OBS: para remover um commit, precisamos selecionar um commit anterior ao que queremos remover, isso vale apenas se estivermos utilizando ID de commit.

--------------------------------------- GIT CONFIG

#config com repo github modo global - identificar quem é o autor dos commits
git config --global user.email "you@example.com"
git config --global user.name "Your Name"

#config com repo github modo local - identificar quem é o autor dos commits
git config user.email "you@example.com"
git config user.name "Your Name"

--------------------------------------- GIT PUSH|PULL|REMOTE

#enviar para o Github
git push origin main
git push repositorio nomegit-branch  #git push origin dev

#se eu tiver certeza do que estou fazendo, pode forçar a escrita no remoto
git push origin main --force

#vincula a branch local com a branch remota. Depois desse comando você não precisa espeficcar qual o repo e a branch, ex: git push ou git pull
git push -u origin main

#push de todas as branches locais para o remoto
git push --all origin       

#push de branchs específicas    
git push origin nome-da-branch1 nome-da-branch2
git push origin dev feature/login

#depois do clone, preciso sincronizar com origin (GitHub), utilizo pull
git pull https://github.com/Bussola2015/Git-Sketch.git
#se já tem vinculo não precisa colocar URL
git pull

#sem merge - git fetch + git rebase - acrescenta as mudanças do remoto no topo do histórico local
git pull --rebase

OBS: git pull=git fetch+(git merge ou git rebase)

#se eu tiver em outra brach
git pull repositorio branch
git pull origin dev

#add outro repo ao workdir - posso ter quantos quiser e não somente o origin inicial
git remote add origin https://github.com/usuario/repo.git
#lista meus repo remoto vinculados
git remote -v  

#remover repo remoto
git remote remove origin

#alterar o nome padrão origin
git remote rename origin novo-origin

#check se tem identificador definido
git config --list

git config user.name
git config user.email
------------------------------------ .GITIGNORE

.gitignore #pode ser encontrado no workdir, Github remoto e em subdiretórios


------------------------------------ BRANCH
#criar branch e entra nela
git checkout -b nova-branch   
ou 
git switch -c nome-da-branch

#criar branch
git branch nome-nova-branch

#alterar de branch
git checkout nome-nova-branch
ou 
git switch nome-branch

#Listar branches existentes:
git branch

#lista as branch com mais detalhes
git branch -v
git branch -vv

#Branches remotas
#Listar branches remotas:
git branch -r

#Listar todas as branches (locais e remotas)
git branch -a

#Criar uma branch local a partir de uma branch remota:
git checkout -b nome-da-branch origin/nome-da-branch

#Excluir uma branch:
git branch -d nome-da-branch

#Forçar exclusão da branch
git branch -D nome-da-branch

#Renomear uma branch
git branch -m novo-nome

#força o renomeio 
git branch -M novo nome

#Para renomear uma branch específica:
git branch -m nome-antigo novo-nome


#Controle do HEAD através do checkout - volta no tempo com HEAD, assim podemos reverter o arquivo e seguir uma branch nova a partir dali
git checkout ID-commit


#cria um branch
git checkout -b nova-branch
git commit -m "mensagem"
#voltei para master, mas meu branch criado acima ficou com meu commit
git checkout main

---------------------------------------------------- FORK

# Como funciona o fluxo:
# Você faz o fork:
# O repositório original é copiado para a sua conta no GitHub (fork).
# Agora você tem controle total sobre o fork.
# Clona o fork para o seu workdir:
# Você clona o repositório forkado para o seu computador:
git clone https://github.com/sua-conta/seu-fork.git

# Adiciona o repositório original como remoto adicional (upstream):
# Para acompanhar as alterações do repositório original, adicione-o como um remoto chamado upstream:
git remote add upstream https://github.com/usuario-original/repo-original.git


# Verifica as alterações no repositório original:
# Use o comando git fetch upstream para buscar as alterações do repositório original (upstream):
git fetch upstream

#verifique seus repos remoto
git remote -v

# Isso não altera sua branch local. Ele apenas atualiza as referências locais para as branches do repositório original.
# Verifica as alterações sem aplicá-las:
# Você pode ver os commits ou alterações disponíveis no repositório original:
git log upstream/main

# O que acontece no seu workdir?
# O comando git fetch upstream não altera sua branch local ou seu repositório remoto (fork no GitHub).
# Ele apenas atualiza as referências locais para as branches do repositório original (upstream), permitindo que você veja as alterações disponíveis.
# Se quiser aplicar as alterações do repositório original ao seu fork:
# Mescle as alterações do repositório original com sua branch local:
git merge upstream/main

# Envie as alterações para o seu fork no GitHub:
git push origin main

#Resumo:
# Use git fetch upstream para buscar as alterações do repositório original sem alterar nada no seu repositório local ou remoto.
# Isso acontece no workdir, após você ter clonado o fork e configurado o repositório original como upstream.


------------------------------------------------ GIT MERGE | REBASE
#merge - fundir/unir uma branch na outra branch
#precisa estar no branch que será o DESTINO das mudanças - estou na dev quero merge com a main -> git switch main -> git merge dev (o inverso para main quero merge com a dev)

git merge nome-branch-origem

#rebase é o contrário do merge, precisa está na branch origem para executar git rebase branch-destino
git rebase nome-branch-destino

#unindo commits
git rebase -i HEAD~3 ou git rebase -i ID-commit #ID do anterior ao commit que eu quero

-------------------------------------------------- GIT REFLOG

#tipo um metadado do HEAD - mantém o historico de todos os HEAD
git reflog
------------------------------------------------- GIT STASH

#salva arquivo no workdir ou stage - congela para depois volta de onde parou
git stash
#lista as stashs com IDs
git stash list
#retorna onde estava

git stash apply ID-stash

#precisa remover manualmente a stash salva
git stash drop ID-stash

#equivale git stash apply ID seguido de git stash drop ID - traz o "HEAD" dos stashs salvos 
git stash pop 

#limpa todas as stashs
git stash clear

--------------------------------------------- GIT TAG
#A partir de uma tag, conseguimos criar uma Realese manualmente no GitHub (remoto) - usado para marcar versões de releases, milestones, etc.
#add tag para o commit atual (HEAD) - cria a tag anotada com -m mensagem
git tag -a nome-da-tag -m "mensagem"
git tag -a v0.1.0 -m "mensagem de milestone"

#crio tag para commit específico
git tag -a nome-da-tag ID-commit -m "mensagem"
git tag -a v0.1.0 c23ae2d -m "mensagem de milestone"

#lista tags
git tag

#enviar a tag
git push origin v0.1.0

#envio todas as tags
git push origin --tags

git show nome-tag-ou-versao
git show v0.1.0

#verificar a tag criada anotada
git tag -v nome-da-tag
git tag -v v0.1.0

#remover tag local
git tag -d nome-da-tag
git tag -d v0.1.0   

--------------------------------------------- GIT CHERRY-PICK
#geralmente o que está em branch diferente e queremos trazer esse commit para essa branch. Executo o comando abaixo na branch destino.
#ex: estou na branch realease, não terminei mas já fiz uns commit, precisei ir para a master fazer bugfix e vi que preciso de um correção que eu já fiz na branch realese, assim uso um cherry-pick (commit de outra branch na minha branch atual) que resolve meu problema.
git cherry-pick ID-commit

#depois que corrigiu com cherry pick - lembrando na branch origem
git rebase nome-branch

---------------------------------------------- GIT BISECT

git log --oneline

#inicia a busca
git bisect start
#informar intervalo de busca

#exemplo de onde no historico está ruim - escolhemos no começo HEAD, significa que o último commit está ruim
git bisect bad HEAD

#exemplo de good - esse commit está OK
git bisect good ID-commit

#Acima good e bad formei um intervalo de busca, depois eu vou filtrando com um good ou bad. Nesse casso o commit está bom
git bisect good

#esse commit não é o que eu quero
git bisect bad

#quando eu acahr o commit desejado, é só executar um
git bisect reset

git revert ID-commit

---------------------------------- GIT BLAME

#encontra quem fez as modificações - o responsável pelo commit
git blame nome-arquivo



--------------------- FLUXO GITHUB FLOW - COM REBASE
#FASE 1:
#estou branch main Local
git switch main

#baixo o main remoto
git pull origin main

#FASE 2:
#crio a branch e mudo para ela
git switch -c feature/minha-tarefa 
ou git checkout -b feature/minha-tarefa

#edito os arquivos

#add stage
git add .

git commit -m "Implementando feature X"

#crio a branch no remoto se não existir e publico as mudanças na branch feature no remoto
git push -u origin feature/minha-tarefa

#FASE 3:
#volto para minha branch main local
git switch main

#sincronizo e baixo novamente o repo para manter atualizado evitando conflitos
git pull origin main

#volto e sincronizo para branch feature no local
git switch feature/minha-tarefa

#sincronizo com a minha main - envio os commits para o topo da main local
git rebase main

#atualizo o branch feature remoto 
git push --force-with-lease


--------------------- FLUXO GITHUB FLOW - COM MERGE
#FASE 1:
#estou branch main Local
git switch main

#baixo o main remoto
git pull origin main

#FASE 2:
#crio a branch e mudo para ela
git switch -c feature/nova-api 
ou git checkout -b feature/nova-api

#edito os arquivos

#add stage
git add .

git commit -m "Implementando feature X"

#crio a branch no remoto se não existir e publico as mudanças na branch feature no remoto
git push -u origin feature/nova-api

#FASE 3:
#estou branch feature/nova-api
git pull origin main

#envio as mudanças para o remoto na branch feature/nova-api
git push

#posso fazer dessa maneira mais didática
#saio da branch feature/nova-api e vou para main local
git switch main

git pull origin main
#volto para feature/nova-api
git switch feature/nova-api
#merge main na feature/nova-api
git merge main
#envio as mudanças para o remoto na branch feature/nova-api
git push origin feature/nova-api

#FASE 4:
#PULL REQUEST no GitHub - faço a solicitação para unir a branch feature/nova-api na main
#Interface Web: Abrir PR
#Abre o pedido de mesclagem (feature/nova-api -> main)
#depois de aprovado faço o merge no GitHub

#volto para main local
git switch main
git pull origin main

--------------------------------------------------------GIT FLOW default
#FASE 1:
#estou na master local vou para develop local
git checkout develop

git pull origin develop

#FASE 2:
#crio a branch de feature e mudo para ela
git switch -c feature/cadastro-usuario

#trabalho nos arquivos

#add stage
git add .

git commit -m "Implementando cadastro-usuario"

git push -u origin feature/cadastro-usuario

#FASE 3:
#volto para develop local (estava na feature/cadastro-usuario)
git switch develop

#atualizo o develop local com o develop remoto que pode ter mudado
git pull origin develop

#volto para a branch feature/cadastro-usuario
git switch feature/cadastro-usuario

#faço o merge do develop no feature/cadastro-usuario
git merge develop

#envia as mudanças para o remoto na branch feature/cadastro-usuario - ou git push 
git push origin feature/cadastro-usuario


#FASE 4:
#Interface Web: Abrir PR - Cria PR para integrar feature/cadastro-usuario na develop
#depois de aprovado faço o merge no GitHub

#volto para develop local
git switch develop

#baixo as mudanças do develop remoto
git pull origin develop

#limpo a branch feature/cadastro-usuario local
git branch -d feature/cadastro-usuario

------------------------------------------------------ GITHUB FLOW - MERGE DEFAULT 

#FASE 1:
#estou branch main Local
git switch main

git pull origin main

#FASE 2:
#crio a branch a partir da main e mudo para ela
git switch -c feature/otimizar-performance

#Edição de código...

git add .
git commit -m "Implementando otimizacao de cache"

git push -u origin feature/otimizar-performance

#FASE 3:
#volto para minha branch main local
git switch main 

#sincronizo e baixo novamente o repo para manter atualizado evitando conflitos
git pull origin main    

#volto e sincronizo para branch feature no local    
git switch feature/otimizar-performance

#merge main na feature/otimizar-performance
git merge main

#atualizo o branch feature remoto 
git push origin feature/otimizar-performance    

#FASE 4:
#PULL REQUEST no GitHub - faço a solicitação para unir a branch feature/otimizar-performance na main
#Interface Web: Abrir PR
#Abre o pedido de mesclagem (feature/otimizar-performance -> main)
#depois de aprovado faço o merge no GitHub      

#volto para main local
git switch main  

git pull origin main

#limpo a branch feature/otimizar-performance local
git branch -d feature/otimizar-performance  

#estou na main local e removo a branch do remoto
git push origin :feature/otimizar-performance  #remove a branch do remoto


